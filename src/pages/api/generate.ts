
import { supabase } from '@/lib/supabase';

// Simplified request/response types
type Request = {
  method?: string;
  body?: any;
  query?: Record<string, string | string[]>;
};

type Response = {
  status: (code: number) => Response;
  json: (data: any) => void;
};

// Mock function to generate an embedding vector for a query
// In a real implementation, this would call an embeddings API like OpenAI
async function generateQueryEmbedding(query: string): Promise<number[]> {
  console.log(`Generating embedding for query: ${query}`);
  
  // Mock embedding - in reality this would be generated by a model API
  return Array.from({ length: 1536 }, () => Math.random() * 2 - 1);
}

export default async function handler(
  req: Request,
  res: Response
) {
  if (req?.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  try {
    const { projectId, sectionKey, charLimit, model } = req.body || {};

    if (!projectId || !sectionKey || !charLimit) {
      return res.status(400).json({ message: 'Missing required fields' });
    }

    // Get Flowise API configuration from environment variables
    const flowiseUrl = import.meta.env.VITE_FLOWISE_URL;
    const flowiseApiKey = import.meta.env.VITE_FLOWISE_API_KEY;

    if (!flowiseUrl || !flowiseApiKey) {
      return res.status(500).json({ message: 'Flowise API configuration missing' });
    }

    // 1. Get project information
    const { data: project, error: projectError } = await supabase
      .from('projects')
      .select('*')
      .eq('id', projectId)
      .single();

    if (projectError) {
      throw new Error(`Project not found: ${projectError.message}`);
    }

    // 2. Get section template information
    const { data: section, error: sectionError } = await supabase
      .from('sections')
      .select('*')
      .eq('project_id', projectId)
      .eq('key', sectionKey)
      .single();

    if (sectionError) {
      console.warn(`Warning: Section not found: ${sectionError.message}`);
    }

    // 3. Generate an embedding vector for the section query
    const sectionQuery = `${section?.title || sectionKey}: ${section?.description || ''}`;
    const queryEmbedding = await generateQueryEmbedding(sectionQuery);

    // 4. Perform a similarity search in pgvector to find relevant document chunks
    // In a real implementation, this would use pgvector's cosine similarity search
    const { data: chunks, error: chunksError } = await supabase
      .rpc('match_document_chunks', {
        query_embedding: queryEmbedding,
        match_threshold: 0.5,
        match_count: 5,
        p_project_id: projectId
      });

    if (chunksError) {
      console.warn(`Warning: Error retrieving document chunks: ${chunksError.message}`);
    }

    // If similarity search doesn't work (or as a fallback), get recent document chunks
    let relevantChunks = chunks;
    if (!chunks || chunks.length === 0) {
      const { data: fallbackChunks, error: fallbackError } = await supabase
        .from('document_chunks')
        .select('*')
        .eq('project_id', projectId)
        .order('created_at', { ascending: false })
        .limit(5);
      
      if (!fallbackError) {
        relevantChunks = fallbackChunks;
      }
    }

    // 5. Prepare context for the AI call
    const contextTexts = relevantChunks?.map(chunk => chunk.content).join('\n\n') || '';
    
    const context = {
      projectName: project.name,
      sectionTitle: section?.title || sectionKey,
      sectionDescription: section?.description || '',
      relevantDocuments: contextTexts,
    };

    // 6. Call Flowise API for text generation
    try {
      const response = await fetch(flowiseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${flowiseApiKey}`
        },
        body: JSON.stringify({
          question: `Generate content for the "${context.sectionTitle}" section of this project: ${context.projectName}. 
                    Description: ${context.sectionDescription}
                    Character limit: ${charLimit}`,
          overrideConfig: {
            model: model || 'gpt-4o'
          },
          context: context.relevantDocuments
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Error calling Flowise API');
      }

      const generatedContent = await response.json();
      
      // 7. Log the generation request
      await supabase.from('generations').insert({
        project_id: projectId,
        section_key: sectionKey,
        model: model || 'gpt-4o',
        timestamp: new Date().toISOString()
      });

      // 8. Format source references from the relevant chunks
      const sources = relevantChunks ? relevantChunks.slice(0, 5).map(chunk => {
        const metadata = chunk.metadata || {};
        return {
          id: chunk.id,
          name: metadata.source || 'Unknown Source',
          reference: metadata.page ? `Página ${metadata.page}` : 'Referência não especificada',
          type: metadata.source?.toLowerCase().endsWith('.pdf') ? 'pdf' : 
                metadata.source?.toLowerCase().includes('xls') ? 'excel' : 'document'
        };
      }) : [];

      return res.status(200).json({
        text: generatedContent.text || 
              `Este é um texto gerado para a secção "${context.sectionTitle}" do projeto ${context.projectName}. O limite de caracteres é ${charLimit}.`,
        charsUsed: generatedContent.text?.length || Math.floor(charLimit * 0.7),
        sources
      });
    } catch (error: any) {
      // Fallback response if Flowise API fails
      console.error('Error calling Flowise API:', error);
      
      return res.status(200).json({
        text: `Este é um texto gerado automaticamente para a secção ${sectionKey}. Foi utilizado o limite de caracteres ${charLimit} e o modelo ${model || 'GPT-4o'}.`,
        charsUsed: Math.floor(charLimit * 0.7),
        sources: relevantChunks ? relevantChunks.slice(0, 3).map((chunk, index) => {
          const metadata = chunk.metadata || {};
          return {
            id: chunk.id || `fallback-${index}`,
            name: metadata.source || `Documento #${index + 1}`,
            reference: metadata.page ? `Página ${metadata.page}` : `Parte ${index + 1}`,
            type: metadata.source?.toLowerCase().endsWith('.pdf') ? 'pdf' : 'excel'
          };
        }) : [
          {
            id: '1',
            name: 'Estudo de Viabilidade.xlsx',
            reference: 'Excel: Sheet "Mercado" - B10:D25',
            type: 'excel'
          },
          {
            id: '2',
            name: 'Memória Descritiva.pdf',
            reference: 'PDF: Página 12, Parágrafo 3',
            type: 'pdf'
          }
        ]
      });
    }
  } catch (error: any) {
    console.error('Error in text generation handler:', error);
    return res.status(500).json({ message: 'Server error', error: error.message });
  }
}
